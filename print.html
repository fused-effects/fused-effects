<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fused-effects</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">fused-effects</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><code>fused-effects</code> is an <a href="https://en.wikipedia.org/wiki/Effect_system">effect system</a> for Haskell that values expressivity, efficiency, and rigor. It provides an encoding of <a href="overview.html#algebraic-effects">algebraic</a>, <a href="overview.html#higher-order-effects">higher-order</a> effects, includes a library of the most common effects, and generates efficient code by <a href="overview.html#fusion">fusing</a> effect handlers through computations. It is suitable for use in hobbyist, research, and industrial contexts.</p>
<p>Readers already familiar with effect systems may wish to start with the <a href="overview.html#usage">usage</a> instead. For those interested, this <a href="https://www.youtube.com/watch?v=vfDazZfxlNs">talk at Strange Loop</a> outlines the history of and motivation behind effect systems and <code>fused-effects</code> itself.</p>
<!--
Setup, hidden from the rendered markdown.

```haskell
{-# LANGUAGE ConstraintKinds, FlexibleInstances, GeneralizedNewtypeDeriving, MultiParamTypeClasses, UndecidableInstances #-}
module Main (module Main) where

import Control.Algebra
import Control.Carrier.Lift
import Control.Carrier.Reader
import Control.Carrier.State.Strict
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = pure ()
```
-->
<h2 id="algebraic-effects"><a class="header" href="#algebraic-effects">Algebraic effects</a></h2>
<p>In <code>fused-effects</code> and other systems with <em>algebraic</em> (or, sometimes, <em>extensible</em>) effects, effectful programs are split into two parts: the specification (or <em>syntax</em>) of the actions to be performed, and the interpretation (or <em>semantics</em>) given to them.</p>
<p>In <code>fused-effects</code>, <em>effect types</em> provide syntax and <em>carrier types</em> provide semantics. Effect types are datatypes with one constructor for each action, invoked using the <code>send</code> builtin. Carriers are monads, with an <code>Algebra</code> instance specifying how an effect’s constructors should be interpreted. Carriers can handle more than one effect, and multiple carriers can be defined for the same effect, corresponding to different interpreters for the effect’s syntax.</p>
<h2 id="higher-order-effects"><a class="header" href="#higher-order-effects">Higher-order effects</a></h2>
<p>Unlike some other effect systems, <code>fused-effects</code> offers <em>higher-order</em> (or <em>scoped</em>) effects in addition to first-order algebraic effects. In a strictly first-order algebraic effect system, operations like <code>local</code> or <code>catchError</code>, which specify some action limited to a given scope, must be implemented as interpreters, hard-coding their meaning in precisely the manner algebraic effects were designed to avoid. By specifying effects as higher-order functors, this limitation is removed, meaning that these operations admit a variety of interpretations. This means, for example, that you can introspect and redefine both the <code>local</code> and <code>ask</code> operations provided by the <code>Reader</code> effect, rather than solely <code>ask</code> (as is the case with certain formulations of algebraic effects).</p>
<p>As Nicolas Wu et al. showed in <em>[Effect Handlers in Scope][]</em>, this has implications for the expressiveness of effect systems. It also has the benefit of making effect handling more consistent, since scoped operations are just syntax which can be interpreted like any other, and are thus simpler to reason about.</p>
<h2 id="fusion"><a class="header" href="#fusion">Fusion</a></h2>
<p>In order to maximize efficiency, <code>fused-effects</code> applies <em>fusion laws</em>, avoiding the construction of intermediate representations of effectful computations between effect handlers. In fact, this is applied as far as the initial construction as well: there is no representation of the computation as a free monad parameterized by some syntax type. As such, <code>fused-effects</code> avoids the overhead associated with constructing and evaluating any underlying free or freer monad.</p>
<p>Instead, computations are performed in a carrier type for the syntax, typically a monad wrapping further monads, via an instance of the <code>Carrier</code> class. This carrier is specific to the effect handler selected, but since it isn’t described until the handler is applied, the separation between specification and interpretation is maintained. Computations are written against an abstract effectful signature, and only specialized to some concrete carrier when their effects are interpreted.</p>
<p>Since the interpretation of effects is written as a typeclass instance which <code>ghc</code> is eager to inline, performance is excellent: approximately on par with <code>mtl</code>.</p>
<p>Finally, since the fusion of carrier algebras occurs as a result of the selection of the carriers, it doesn’t depend on complex <code>RULES</code> pragmas, making it easy to reason about and tune.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<h2 id="package-organization"><a class="header" href="#package-organization">Package organization</a></h2>
<p>The <code>fused-effects</code> package is organized into two module hierarchies:</p>
<ul>
<li>those under <code>Control.Effect</code>, which provide effects and functions that invoke these effects’ capabilities.</li>
<li>those under <code>Control.Carrier</code>, which provide carrier types capable of executing the effects described by a given effect type.</li>
</ul>
<p>An additional module, <code>Control.Algebra</code>, provides the <code>Algebra</code> interface that carrier types implement to provide an interpretation of a given effect. You shouldn’t need to import it unless you’re defining your own effects.</p>
<h2 id="invoking-effects"><a class="header" href="#invoking-effects">Invoking effects</a></h2>
<p>Each module under the <code>Control.Effect</code> hierarchy provides a set of functions that invoke effects, each mapping to a constructor of the underlying effect type. These functions are similar to, but more powerful than, those provided by <code>mtl</code>. In this example, we invoke the <code>get</code> and <code>put</code> functions provided by <code>Control.Effect.State</code>, first extracting the state and then updating it with a new value:</p>
<pre><code class="language-haskell">action1 :: Has (State String) sig m =&gt; m ()
action1 = get &gt;&gt;= \ s -&gt; put ("hello, " ++ s)
</code></pre>
<p>The <code>Has</code> constraint requires a given effect (here <code>State</code>) to be present in a <em>signature</em> (<code>sig</code>), and relates that signature to be present in a carrier type (<code>m</code>). We generally, but not always, program against an abstract carrier type, usually called <code>m</code>, as carrier types always implement the <code>Monad</code> typeclass.</p>
<p>To add effects to a given computation, add more <code>Has</code> constraints to the signature/carrier pair <code>sig</code> and <code>m</code>. For example, to add a <code>Reader</code> effect managing an <code>Int</code>, we would write:</p>
<pre><code class="language-haskell">action2 :: (Has (State String) sig m, Has (Reader Int) sig m) =&gt; m ()
action2 = do
  i &lt;- ask
  put (replicate i '!')
</code></pre>
<h2 id="running-effects"><a class="header" href="#running-effects">Running effects</a></h2>
<p>Effects are run with <em>effect handlers</em>, specified as functions (generally starting with <code>run…</code>) unpacking some specific monad with a <code>Carrier</code> instance. For example, we can run a <code>State</code> computation using <code>runState</code>, imported from the <code>Control.Carrier.State.Strict</code> carrier module:</p>
<pre><code class="language-haskell">example1 :: Algebra sig m =&gt; [a] -&gt; m (Int, ())
example1 list = runState 0 $ do
  i &lt;- get
  put (i + length list)
</code></pre>
<p><code>runState</code> returns a tuple of both the computed value (the <code>()</code>) and the final state (the <code>Int</code>), visible in the result of the returned computation. The <code>get</code> function is resolved with a visible type application, due to the fact that effects can contain more than one state type (in contrast with <code>mtl</code>’s <code>MonadState</code>, which limits the user to a single state type).</p>
<p>Since this function returns a value in some carrier <code>m</code>, effect handlers can be chained to run multiple effects. Here, we get the list to compute the length of from a <code>Reader</code> effect:</p>
<pre><code class="language-haskell">example2 :: Algebra sig m =&gt; m (Int, ())
example2 = runReader "hello" . runState 0 $ do
  list &lt;- ask
  put (length (list :: String))
</code></pre>
<p>(Note that the type annotation on <code>list</code> is necessary to disambiguate the requested value, since otherwise all the typechecker knows is that it’s an arbitrary <code>Foldable</code>. For more information, see the <a href="usage.html#comparison-to-mtl">comparison to <code>mtl</code></a>.)</p>
<p>When all effects have been handled, a computation’s final value can be extracted with <code>run</code>:</p>
<pre><code class="language-haskell">example3 :: (Int, ())
example3 = run . runReader "hello" . runState 0 $ do
  list &lt;- ask
  put (length (list :: String))
</code></pre>
<p><code>run</code> is itself actually an effect handler for the <code>Lift Identity</code> effect, whose only operation is to lift a result value into a computation.</p>
<p>Alternatively, arbitrary <code>Monad</code>s can be embedded into effectful computations using the <code>Lift</code> effect. In this case, the underlying <code>Monad</code>ic computation can be extracted using <code>runM</code>. Here, we use the <code>MonadIO</code> instance for the <code>LiftC</code> carrier to lift <code>putStrLn</code> into the middle of our computation:</p>
<pre><code class="language-haskell">example4 :: IO (Int, ())
example4 = runM . runReader "hello" . runState 0 $ do
  list &lt;- ask
  liftIO (putStrLn list)
  put (length list)
</code></pre>
<p>(Note that we no longer need to give a type annotation for <code>list</code>, since <code>putStrLn</code> constrains the type for us.)</p>
<h2 id="required-compiler-extensions"><a class="header" href="#required-compiler-extensions">Required compiler extensions</a></h2>
<p>When defining your own effects, you may need <code>-XKindSignatures</code> if GHC cannot correctly infer the type of your constructor; see the <a href="https://github.com/fused-effects/fused-effects/blob/master/docs/common_errors.md">documentation on common errors</a> for more information about this case.</p>
<p>When defining carriers, you’ll need <code>-XTypeOperators</code> to declare a <code>Carrier</code> instance over (<code>:+:</code>), <code>-XFlexibleInstances</code> to loosen the conditions on the instance, <code>-XMultiParamTypeClasses</code> since <code>Carrier</code> takes two parameters, and <code>-XUndecidableInstances</code> to satisfy the coverage condition for this instance.</p>
<p>The following invocation, taken from the teletype example, should suffice for most use or construction of effects and carriers:</p>
<pre><code class="language-haskell">{-# LANGUAGE FlexibleInstances, GeneralizedNewtypeDeriving, MultiParamTypeClasses, TypeOperators, UndecidableInstances #-}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-new-effects"><a class="header" href="#defining-new-effects">Defining new effects</a></h1>
<p>Effects are a powerful mechanism for abstraction, and so defining new effects is a valuable tool for system architecture. Effects are modelled as (higher-order) functors, with an explicit continuation denoting the remainder of the computation after the effect.</p>
<p>It’s often helpful to start by specifying the types of the desired operations. For our example, we’re going to define a <code>Teletype</code> effect, with <code>read</code> and <code>write</code> operations, which read a string from some input and write a string to some output, respectively:</p>
<pre><code class="language-haskell">data Teletype (m :: Type -&gt; Type) k
read :: Has Teletype sig m =&gt; m String
write :: Has Teletype sig m =&gt; String -&gt; m ()
</code></pre>
<p>Effect types must have two type parameters: <code>m</code>, denoting any computations which the effect embeds, and <code>k</code>, denoting the remainder of the computation after the effect. Note that since <code>Teletype</code> doesn’t use <code>m</code>, the compiler will infer it as being of kind <code>*</code> by default. The explicit kind annotation on <code>m</code> corrects that.</p>
<p>Next, we can flesh out the definition of the <code>Teletype</code> effect by providing constructors for each primitive operation:</p>
<pre><code class="language-haskell">data Teletype (m :: Type -&gt; Type) k where
  Read  ::           Teletype m String
  Write :: String -&gt; Teletype m ()
</code></pre>
<p>The <code>Read</code> operation returns a <code>String</code>, and hence its result type is <code>String</code>. Thus, to interpret this constructor, an algebra will have to produce a <code>String</code>. But since the effect type doesn’t say anything about where that <code>String</code> should come from, algebras are free to read from <code>stdin</code>, use a constant value, etc. By contrast, the <code>Write</code> operation takes a <code>String</code> and returns <code>()</code>.</p>
<p>Now that we have our effect datatype, we can give definitions for <code>read</code> and <code>write</code>:</p>
<pre><code class="language-haskell">read :: Has Teletype sig m =&gt; m String
read = send Read

write :: Has Teletype sig m =&gt; String -&gt; m ()
write s = send (Write s)
</code></pre>
<p>This gives us enough to write computations using the <code>Teletype</code> effect. The next section discusses how to run <code>Teletype</code> computations.</p>
<h2 id="defining-algebras"><a class="header" href="#defining-algebras">Defining algebras</a></h2>
<p>Effects only specify actions, they don’t actually specify how any actions should be performed. That task is left up to algebras, defined as <code>Algebra</code> instances.</p>
<p>Following from the above section, we can define a carrier for the <code>Teletype</code> effect which runs the calls in an underlying <code>MonadIO</code> instance, accessed via our carrier’s own <code>GenericNewtypeDeriving</code>-derived instance:</p>
<pre><code class="language-haskell">newtype TeletypeIOC m a = TeletypeIOC { runTeletypeIO :: m a }
  deriving (Applicative, Functor, Monad, MonadIO)

instance (MonadIO m, Algebra sig m) =&gt; Algebra (Teletype :+: sig) (TeletypeIOC m) where
  alg hdl sig ctx = case sig of
    L Read      -&gt; (&lt;$ ctx) &lt;$&gt; liftIO getLine
    L (Write s) -&gt; ctx      &lt;$  liftIO (putStrLn s)
    R other     -&gt; TeletypeIOC (alg (runTeletypeIO . hdl) other ctx)
</code></pre>
<p>Here, <code>alg</code> is responsible for handling effectful computations. Since the <code>Algebra</code> instance handles a sum (<code>:+:</code>) of <code>Teletype</code> and the remaining signature, <code>alg</code> has two parts: a case for the <code>Teletype</code> effect (in <code>L</code>), and a case for effects in the tail of the signature (in <code>R</code>).</p>
<p>The <code>Teletype</code> effect is handled with a case per constructor. Since we’re assuming the existence of a <code>MonadIO</code> instance for the underlying computation, we use <code>liftIO</code> to inject the <code>getLine</code> and <code>putStrLn</code> actions into it, and simply bundle up the initial state <code>ctx</code> with the results.</p>
<p>Since the <code>Teletype</code> carrier is just a thin wrapper around the underlying computation, we can handle the tail of the signature by passing <code>alg</code> a function to unwrap any embedded <code>TeletypeIOC</code> values by simply composing <code>runTeletypeIO</code> onto <code>hdl</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reinterpreting-effects"><a class="header" href="#reinterpreting-effects">Reinterpreting effects</a></h1>
<p>This article assumes you are already familiar with <a href="defining_effects.html">defining effects and their handlers</a>.</p>
<p>One of the nice aspects of effects is that they can support multiple effect handlers. Effects only specify actions, they don't actually perform them. Therefore, it's possible to "reinterpret" effects. There are multiple senses in which an effect can be reinterpreted:</p>
<ul>
<li>Implementing an effect in terms of other effects. "Reinterpreting" effects is a powerful tool for cleanly dividing implementations into the relevant abstraction layers with minimal leakage of implementation details.</li>
<li>Rewriting an effect and/or performing actions with the effect value and then performing the originally intended effect. This technique is conceptually similar to the middleware pattern commonly used in web applications. This known as <em>interposition</em> (see works by Oleg Kiselyov et al.)</li>
</ul>
<p>Let's explore both of these effect interpretation strategies with a small motivating example:</p>
<p>✨ We would like to implement a client library for an <a href="https://alexwohlbruck.github.io/cat-facts/docs/">HTTP-based API that provides interesting cat facts</a>. ✨</p>
<p>Let's break down some of the properties of the API client that would be desirable for a production use case:</p>
<ol>
<li>We would like to have our cat facts API be able to support different cat fact data sources in the future.</li>
<li>We would like to be able to mock failure conditions (such as network connectivity issues) for testing purposes.</li>
<li>We would like to be able to track timing metrics for how quickly we can retrieve cat facts.</li>
</ol>
<h3 id="initial-setup"><a class="header" href="#initial-setup">Initial setup</a></h3>
<pre><code class="language-haskell">{-# LANGUAGE ExistentialQuantification, FlexibleInstances, GADTs,
GeneralizedNewtypeDeriving, KindSignatures, OverloadedStrings, MultiParamTypeClasses,
RankNTypes, TypeApplications, TypeOperators, UndecidableInstances #-}
module CatFacts
    ( main
    ) where
-- from base
import Control.Applicative
import Data.Foldable (traverse_)
import Control.Exception (throwIO)
import Data.Kind (Type)
-- from fused-effects
import Control.Algebra
import Control.Carrier.Reader
import Control.Carrier.Error.Either
import Control.Carrier.Interpret
-- from transformers
import Control.Monad.IO.Class
-- From aeson
import Data.Aeson
-- From bytestring
import qualified Data.ByteString.Char8 as B
import qualified Data.ByteString.Lazy as L
-- From time
import Data.Time.Clock
-- From http-client
import qualified Network.HTTP.Client as HTTP
import Network.HTTP.Client.Internal (Response(..), ResponseClose(..))
-- From http-client-tls
import qualified Network.HTTP.Client.TLS as HTTP
-- From http-status
import Network.HTTP.Types.Header
import Network.HTTP.Types.Status
import Network.HTTP.Types.Version
</code></pre>
<p>Since one of the best parts about effects is being able to think at a domain language level,let's start with defining the desired data which we wish to retrieve and an interface that feels natural to work with:</p>
<pre><code class="language-haskell">-- | The basic fact that we will retrieve.
newtype CatFact = CatFact
  { catFact :: String
  } deriving (Show)

instance FromJSON CatFact where
  parseJSON = withObject "CatFact" (\o -&gt; CatFact &lt;$&gt; o .: "text")

-- | Our high level effect type that will be able to target different data sources.
data CatFactClient (m :: Type -&gt; Type) k where
  ListFacts :: Int {- ^ Number of facts to fetch -} -&gt; CatFactClient m [CatFact]

listFacts :: Has CatFactClient sig m =&gt; Int -&gt; m [CatFact]
listFacts n = send (ListFacts n)
</code></pre>
<p>Now that we have our very simple DSL in place, let's think about the underlying API: we know that it's an HTTP-based system, so let's introduce the notion of a handler that is provided a request and hands back an HTTP response.</p>
<pre><code class="language-haskell">data Http (m :: Type -&gt; Type) k where
  SendRequest :: HTTP.Request -&gt; Http m (HTTP.Response L.ByteString)

sendRequest :: Has Http sig m =&gt; HTTP.Request -&gt; m (HTTP.Response L.ByteString)
sendRequest r = send (SendRequest r)
</code></pre>
<p>The <code>listFacts</code> function provides the ‘what’ of this API, and the <code>sendRequest</code> function provides the ‘how’. In decomposing this problem into a set of effects, each responsible for a single layer of the original problem description, we provide ourselves with a flexible, composable vocabulary rather than a single monolithic action.</p>
<h2 id="stacking-effects"><a class="header" href="#stacking-effects">"Stacking" effects</a></h2>
<h3 id="the-production-use-case"><a class="header" href="#the-production-use-case">The production use-case</a></h3>
<p>Now that we have these two mini-DSL effect types established, we need to stitch them together.</p>
<p>Let's take a moment to think about what could go wrong with an HTTP API from which we plan to fetch some JSON and convert it into a list of <code>CatFact</code>s.</p>
<p>We can conceive that the server might occasionally return a malformed JSON response:</p>
<pre><code class="language-haskell">newtype JsonParseError = JsonParseError String
  deriving (Show, Eq)

decodeOrThrow :: (Has (Throw JsonParseError) sig m, FromJSON a) =&gt; L.ByteString -&gt; m a
decodeOrThrow = either (throwError . JsonParseError) pure . eitherDecode
</code></pre>
<p>A more HTTP-centric issue is that we might receive a content type we can't use. In this case, anything that's not <code>application/json</code>:</p>
<pre><code class="language-haskell">newtype InvalidContentType = InvalidContentType String
  deriving (Show, Eq)
</code></pre>
<p>Now we need to support fetching JSON given an HTTP request. We have no guarantee that an arbitrary HTTP request will actually return JSON, so for this implementation we have to account for failure conditions. This provides a great opportunity to see how effect handlers can actually rely on <em>multiple underlying effects</em>!</p>
<pre><code class="language-haskell">newtype CatFactsApi m a = CatFactsApi { runCatFactsApi :: m a }
 deriving
   ( Monad
   , Functor
   , Applicative
   , MonadIO
   , Alternative
   )

catFactsEndpoint :: HTTP.Request
catFactsEndpoint = HTTP.parseRequest_ "https://cat-fact.herokuapp.com/facts/random"

instance ( Has Http sig m
         , Has (Throw JsonParseError) sig m
         , Has (Throw InvalidContentType) sig m
         , Algebra sig m
         ) =&gt;
         Algebra (CatFactClient :+: sig) (CatFactsApi m) where
  alg hdl sig ctx = case sig of
    L (ListFacts numberOfFacts) -&gt; do
      resp &lt;- sendRequest (catFactsEndpoint { HTTP.queryString = "?amount=" &lt;&gt; B.pack (show numberOfFacts) })
      case lookup hContentType (HTTP.responseHeaders resp) of
        Just "application/json; charset=utf-8" -&gt; (&lt;$ ctx) &lt;$&gt; decodeOrThrow (HTTP.responseBody resp)
        other -&gt; throwError (InvalidContentType (show other))
    R other -&gt; CatFactsApi (alg (runCatFactsApi . hdl) other ctx)
</code></pre>
<p>We implement a <code>CatFacts</code> effect handler that depends on <em>three</em> underlying effects:</p>
<ol>
<li><code>Http</code> - we need to be able to make requests</li>
<li><code>Throw JsonParseError</code> - we need to be able to signal that some aspect of the JSON wasn't what we expected.</li>
<li><code>Throw InvalidContentType</code> - we need to be able to signal what we got wasn't JSON at all!</li>
</ol>
<p>The nice aspect of this is that we have neatly contained the failure scenarios to their relevant strata rather than leaking them into the higher-level abstraction (<code>listFacts</code>)!</p>
<p>Now we need to support performing HTTP requests:</p>
<pre><code class="language-haskell">newtype HttpClient m a = HttpClient { runHttp :: m a }
  deriving
    ( Monad
    , Functor
    , Applicative
    , MonadIO
    , Alternative
    )

instance (MonadIO m, Algebra sig m) =&gt; Algebra (Http :+: sig) (HttpClient m) where
  alg hdl sig ctx = case sig of
    L (SendRequest req) -&gt; (&lt;$ ctx) &lt;$&gt; liftIO (HTTP.getGlobalManager &gt;&gt;= HTTP.httpLbs req)
    R other -&gt; HttpClient (alg (runHttp . hdl) other ctx)
</code></pre>
<p>Note for the above code snippets how the <code>CatFactsApi</code> carrier delegates fetching JSON to any other effect that supports retrieving JSON given an HTTP request specification.</p>
<p>Note as well that <code>CatFactsApi</code> itself doesn't know how to perform an HTTP request. It delegates the request itself to a handler that implements the <code>Algebra</code> class for <code>(Http :+: sig)</code>.</p>
<p>Putting it all together for the actual production use case:</p>
<pre><code class="language-haskell">handlePrint :: Either InvalidContentType (Either JsonParseError [CatFact]) -&gt; IO ()
handlePrint r =
  case r of
    Left invalidContentTypeError -&gt; print invalidContentTypeError
    Right ok -&gt; case ok of
      Left jsonParseError -&gt; print jsonParseError
      Right facts -&gt; traverse_ (putStrLn . catFact) facts

catFactsRunner :: Has Http sig m =&gt; m (Either InvalidContentType (Either JsonParseError [CatFact]))
catFactsRunner =
  runError @InvalidContentType $
  runError @JsonParseError $
  runCatFactsApi $
  listFacts 10

main :: IO ()
main = runHttp catFactsRunner &gt;&gt;= handlePrint
</code></pre>
<p>Produces:</p>
<pre><code>The Bengal is the result of crossbreeding between domestic cats and Asian leopard cats, and its name is derived from the scientific name for the Asian leopard cat (Felis bengalensis).
A happy cat holds her tail high and steady.
Kittens remain with their mother till the age of 9 weeks.
Recent studies have shown that cats can see blue and green. There is disagreement as to whether they can see red.
A steady diet of dog food may cause blindness in your cat - it lacks taurine.
Cat owners are 25% likely to pick George Harrison as their favorite Beatle.
The catnip plant contains an oil called hepetalactone which does for cats what marijuana does to some people. Not all cats react to it those that do appear to enter a trancelike state. A positive reaction takes the form of the cat sniffing the catnip, then licking, biting, chewing it, rub &amp; rolling on it repeatedly, purring, meowing &amp; even leaping in the air.
The color of the points in Siamese cats is heat related. Cool areas are darker.
Cats have free-floating clavicle bones that attach their shoulders to their forelimbs, which allows them to squeeze through very small spaces.
Wikipedia has a recording of a cat meowing, because why not?
</code></pre>
<h3 id="testing-with-alternative-effect-handlers"><a class="header" href="#testing-with-alternative-effect-handlers">Testing with alternative effect handlers</a></h3>
<p>Per point 2. of our initial implementation criteria, we want to be able to simulate failure cases for testing purposes. This is a great case for swapping in an alternative effect handler for our HTTP layer.</p>
<p>This time let's go from the bottom up. In situations where IO is involved, failure scenarios tend to surface from least-pure parts of code. In this case, we should therefore implement some facilities to experiment with the most failure-prone area: the network itself.</p>
<pre><code class="language-haskell">newtype MockHttpClient m a = MockHttpClient { runMockHttpClient :: ReaderC (HTTP.Request -&gt; IO (HTTP.Response L.ByteString)) m a }
  deriving
   ( Monad
   , Functor
   , Applicative
   , MonadIO
   , Alternative
   )

runMockHttp :: (HTTP.Request -&gt; IO (HTTP.Response L.ByteString)) -&gt; MockHttpC m a -&gt; m a
runMockHttp responder m = runReader responder (runMockHttpClient m)

instance (MonadIO m, Algebra sig m) =&gt; Algebra (Http :+: sig) (MockHttpClient m) where
  alg hdl sig ctx = case sig of
    L (SendRequest req) -&gt; do
      responder &lt;- MockHttpClient ask
      (&lt;$ ctx) &lt;$&gt; liftIO (responder req)
    R other -&gt; MockHttpClient (alg (runMockHttpClient . hdl) (R other) ctx)

faultyNetwork :: HTTP.Request -&gt; IO (HTTP.Response L.ByteString)
faultyNetwork req = throwIO (HTTP.HttpExceptionRequest req HTTP.ConnectionTimeout)

wrongContentType :: HTTP.Request -&gt; IO (HTTP.Response L.ByteString)
wrongContentType req = pure resp
  where
    resp = Response
      { responseStatus = ok200
      , responseVersion = http11
      , responseHeaders = [("Content-Type", "text/xml")]
      , responseBody = "[{\"text\": \"Cats are not dogs\"}]"
      , responseCookieJar = mempty
      , responseClose' = ResponseClose (pure ())
      }

badJson :: HTTP.Request -&gt; IO (HTTP.Response L.ByteString)
badJson req = pure Response
  { responseStatus = ok200
  , responseVersion = http11
  , responseHeaders = [("Content-Type", "application/json; charset=utf-8")]
  , responseBody = "{}"
  , responseCookieJar = mempty
  , responseClose' = ResponseClose (pure ())
  }
</code></pre>
<p>Let's update our <code>main</code> function and watch it in action:</p>
<pre><code class="language-haskell">main :: IO ()
main = do
  -- Should return JsonParseError
  runMockHttp badJson catFactsRunner &gt;&gt;= handlePrint
  -- Should return InvalidContentType
  runMockHttp wrongContentType catFactsRunner &gt;&gt;= handlePrint
</code></pre>
<p>Which returns:</p>
<pre><code class="language-haskell">JsonParseError "Error in $: parsing [] failed, expected Array, but encountered Object"
InvalidContentType "Just \"text/xml\""
</code></pre>
<p>With effects, we have fine-grained ways of testing slices of our API. All that's needed to turn an integration test into a unit test or vice versa is a different set of <code>Algebra</code>-implementing effect handlers!</p>
<h2 id="observing--altering-effects"><a class="header" href="#observing--altering-effects">Observing &amp; altering effects</a></h2>
<p>Building new effect handling algebras can be a little bit verbose. In simpler situations, we may want to simply operate
on an effect without having to implement a whole new <code>Algebra</code> instance. We still have yet to build a solution to tracking
operational metrics (like request timings), so let's look at how to build a sort of "effect middleware" using <code>InterpretC</code>.</p>
<p><code>InterpretC</code> is an effect carrier that is intended for prototyping new effects that passes a callback function each
occurence of the specified effect type that is called via <code>send</code>. One trick that can be useful is to intercept an effect,
operate on the effect, and then re-<code>send</code> the effect (a.k.a. interposition). In other words, it's perfectly valid to have multiple handlers
for the same effect type and dispatch to the ones higher in the effect stack! Let's use this approach to time and log
our HTTP requests:</p>
<pre><code class="language-haskell">traceHttp
  :: (Has Http sig m, MonadIO m)
  =&gt; (forall s. Reifies s (Interpreter Http m) =&gt; InterpretC s Http m a)
  -&gt; m a
traceHttp = runInterpret $ \ _ r@(SendRequest req) ctx -&gt; do
  startTime &lt;- liftIO getCurrentTime
  liftIO (putStr (B.unpack (HTTP.path req) ++ " ... "))
  -- Pass the request on to something that actually knows how to respond.
  resp &lt;- sendRequest req
  -- Once the actual response is obtained,
  -- we can capture the end time and status of the response.
  endTime &lt;- liftIO getCurrentTime
  let timeSpent = endTime `diffUTCTime` startTime
  liftIO $ putStrLn ("[" ++ show (statusCode $ HTTP.responseStatus resp) ++ "] took " ++ show timeSpent ++ "\n\n")
  pure (resp &lt;$ ctx)
</code></pre>
<p>Updating our <code>main</code> function once more:</p>
<pre><code class="language-haskell">main :: IO ()
main = runHttp (traceHttp catFactsRunner) &gt;&gt;= handlePrint
</code></pre>
<p>Returns:</p>
<pre><code>/facts/random ... [200] took 0.979107082s


Cats have a special scent organ located in the roof of their mouth, called the Jacobson's organ. It analyzes smells - and is the reason why you will sometimes see your cat "sneer" (called the flehmen response or flehming) when they encounter a strong odor.
It's important for cats to have regular ear exams—this is something you can do at home! Gently fold back the ears and look into the ear canal. The inner ear should be pale pink with little to no earwax. If you notice redness, swelling, discharge, or a lot of earwax, it's time to see a veterinarian.
Siamese kittens are born white because of the heat inside the mother's uterus before birth. This heat keeps the kittens' hair from darkening on the points.
Declawing a cat is the same as cutting a human's fingers off at the knuckle. There are several alternatives to a complete declawing, including trimming or a less radical (though more involved) surgery to remove the claws. Instead, train your cat to use a scratching post.
There is a species of cat smaller than the average housecat. It is native to Africa and it is the Black-footed cat (Felis nigripes). Its top weight is 5.5 pounds.
Gatos.
Cats are the most interesting mammals on earth.
Cats have free-floating clavicle bones that attach their shoulders to their forelimbs, which allows them to squeeze through very small spaces.
Fossil records from two million years ago show evidence of jaguars.
Since cats are so good at hiding illness, even a single instance of a symptom should be taken very seriously.
</code></pre>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>Reviewing our initial criteria, we have an eminently extensible system that lets us maintain a healthy separation of concerns–
All while still allowing non-invasive behavior changes through the ability to intercept, rewrite, and resend effects!</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
We would like to have our cat facts API be able to support different cat fact data sources in the future.</li>
<li><input disabled="" type="checkbox" checked=""/>
We would like to be able to mock failure conditions (such as network connectivity issues) for testing purposes.</li>
<li><input disabled="" type="checkbox" checked=""/>
We would like to be able to track timing metrics for how quickly we can retrieve cat facts.</li>
</ul>
<p><img src="https://media.giphy.com/media/l6Td5sKDNmDGU/giphy.gif" alt="Mission accomplished" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h1>
<p>There are certain classes of errors when using <code>fused-effects</code>
that GHC is not particularly good at explaining. This document
is an attempt to enumerate and explicate the things that can go wrong
when using or extending this library. (It is also very much a work in
progress.)</p>
<h2 id="im-getting-kind-errors-when-implementing-an-algebra-instance"><a class="header" href="#im-getting-kind-errors-when-implementing-an-algebra-instance">I'm getting kind errors when implementing an <code>Algebra</code> instance!</a></h2>
<p>Given an effect datatype that doesn’t use the <code>m</code> parameter:</p>
<pre><code class="language-haskell">data Fail m k where
  Fail :: String -&gt; Fail m a

newtype FailC m a = FailC { runFailC :: m (Either String a) }
</code></pre>
<p>Declaring an <code>Algebra</code> instance will fail:</p>
<pre><code class="language-haskell">instance Algebra sig m
      =&gt; Algebra (Fail :+: sig) (FailC m) where…
</code></pre>
<pre><code>• Expected kind ‘(* -&gt; *) -&gt; * -&gt; *’,
    but ‘Fail :+: sig’ has kind ‘* -&gt; * -&gt; *’
• In the first argument of ‘Algebra’, namely ‘(Fail :+: sig)’
  In the instance declaration for
    ‘Algebra (Fail :+: sig) (FailC m)
</code></pre>
<p>This is because the <code>m</code> parameter to <code>Fail</code> is inferred to be of kind <code>*</code>:
though <code>Algebra</code> expects an <code>m</code> of kind <code>* -&gt; *</code>, <code>m</code> is never referenced in
the definition of <code>Fail</code>, so GHC makes an understandable but incorrect inference.
An explicit kind annotation on <code>m</code> fixes the problem.</p>
<pre><code class="language-haskell">data Fail (m :: * -&gt; *) k where
  Fail :: String -&gt; Fail m a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="related-work"><a class="header" href="#related-work">Related work</a></h1>
<p><code>fused-effects</code> is an encoding of higher-order algebraic effects following the recipes in <em><a href="http://www.cs.ox.ac.uk/people/nicolas.wu/papers/Scope.pdf">Effect Handlers in Scope</a></em> (Nicolas Wu, Tom Schrijvers, Ralf Hinze), <em><a href="http://www.cs.kuleuven.be/publicaties/rapporten/cw/CW699.pdf">Monad Transformers and Modular Algebraic Effects: What Binds Them Together</a></em> (Tom Schrijvers, Maciej Piróg, Nicolas Wu, Mauro Jaskelioff), and <em><a href="https://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/mpc2015.pdf">Fusion for Free—Efficient Algebraic Effect Handlers</a></em> (Nicolas Wu, Tom Schrijvers).</p>
<h2 id="contributed-packages"><a class="header" href="#contributed-packages">Contributed packages</a></h2>
<p>Though we aim to keep the <code>fused-effects</code> core minimal, we encourage the development of external <code>fused-effects</code>-compatible libraries. If you’ve written one that you’d like to be mentioned here, get in touch!</p>
<ul>
<li><a href="http://hackage.haskell.org/package/fused-effects-lens"><code>fused-effects-lens</code></a> provides combinators to use the <a href="http://hackage.haskell.org/package/lens"><code>lens</code></a> library fluently inside effectful computations.</li>
<li><a href="https://github.com/fused-effects/fused-effects-exceptions"><code>fused-effects-exceptions</code></a> provides handlers for exceptions thrown in the <code>IO</code> monad.</li>
<li><a href="https://github.com/fused-effects/fused-effects-resumable"><code>fused-effects-resumable</code></a> provides resumable exceptions, which can also serve as a limited form of coroutines.</li>
<li><a href="https://github.com/fused-effects/fused-effects-mwc-random"><code>fused-effects-mwc-random</code></a> provides a performant, high-quality source of random data, as well as values from common numerical distributions.</li>
<li><a href="https://github.com/fused-effects/fused-effects-readline"><code>fused-effects-readline</code></a> provides a REPL effect that interfaces with <a href="https://hackage.haskell.org/package/haskeline"><code>haskeline</code></a> for its UI.</li>
<li><a href="https://github.com/fused-effects/fused-effects-parser"><code>fused-effects-parser</code></a> provides parser-combinator style effects similar to parsing libraries such as <a href="https://hackage.haskell.org/package/trifecta"><code>trifecta</code></a>.</li>
</ul>
<h2 id="projects-using-fused-effects"><a class="header" href="#projects-using-fused-effects">Projects using <code>fused-effects</code></a></h2>
<ul>
<li><a href="http://github.com/github/semantic"><code>semantic</code></a>, a program analysis toolkit</li>
<li><a href="http://hackage.haskell.org/package/now-haskell"><code>now-haskell</code></a>, a client library for AWS Lambda</li>
</ul>
<h2 id="comparison-to-other-effect-libraries"><a class="header" href="#comparison-to-other-effect-libraries">Comparison to other effect libraries</a></h2>
<h3 id="comparison-to-mtl"><a class="header" href="#comparison-to-mtl">Comparison to <code>mtl</code></a></h3>
<p>Like <a href="http://hackage.haskell.org/package/mtl"><code>mtl</code></a>, <code>fused-effects</code> provides a library of monadic effects which can be given different interpretations. In <code>mtl</code> this is done by defining new instances of the typeclasses encoding the actions of the effect, e.g. <code>MonadState</code>. In <code>fused-effects</code>, this is done by defining new instances of the <code>Carrier</code> typeclass for the effect.</p>
<p>Also like <code>mtl</code>, <code>fused-effects</code> allows scoped operations like <code>local</code> and <code>catchError</code> to be given different interpretations. As with first-order operations, <code>mtl</code> achieves this with a final tagless encoding via methods, whereas <code>fused-effects</code> achieves this with an initial algebra encoding via <code>Carrier</code> instances.</p>
<p>In addition, <code>mtl</code> and <code>fused-effects</code> are similar in that they provide instances for the monad types defined in the <code>transformers</code> package (<code>Control.Monad.Reader</code>, <code>Control.Monad.Writer</code>, etc). This means that applications using <code>mtl</code> can migrate many existing <code>transformers</code>-based monad stacks to <code>fused-effects</code> with minimal code changes. <code>fused-effects</code> provides its own hierarchy of carrier monads (under the <code>Control.Carrier</code> namespace) that provide a more fluent interface for new code, though it may be useful to use <code>transformers</code> types when working with third-party libraries.</p>
<p>Unlike <code>mtl</code>, effects are automatically available regardless of where they occur in the signature; in <code>mtl</code> this requires instances for all valid orderings of the transformers (O(n²) of them, in general).</p>
<p>Also unlike <code>mtl</code>, there can be more than one <code>State</code> or <code>Reader</code> effect in a signature. This is a tradeoff: <code>mtl</code> is able to provide excellent type inference for effectful operations like <code>get</code>, since the functional dependencies can resolve the state type from the monad type.</p>
<p>Unlike <code>fused-effects</code>, <code>mtl</code> provides a <code>ContT</code> monad transformer; however, it’s worth noting that many behaviours possible with delimited continuations (e.g. resumable exceptions) are directly encodable as effects.</p>
<p>Finally, thanks to the fusion and inlining of carriers, <code>fused-effects</code> is only marginally slower than equivalent <code>mtl</code> code (see <a href="related.html#benchmarks">benchmarks</a>).</p>
<h3 id="comparison-to-freer-simple"><a class="header" href="#comparison-to-freer-simple">Comparison to <code>freer-simple</code></a></h3>
<p>Like <a href="http://hackage.haskell.org/package/freer-simple"><code>freer-simple</code></a>, <code>fused-effects</code> uses an initial encoding of library- and user-defined effects as syntax which can then be given different interpretations. In <code>freer-simple</code>, this is done with a family of interpreter functions (which cover a variety of needs, and which can be extended for more bespoke needs), whereas in <code>fused-effects</code> this is done with <code>Carrier</code> instances for <code>newtype</code>s.</p>
<p>Unlike <code>fused-effects</code>, in <code>freer-simple</code>, scoped operations like <code>catchError</code> and <code>local</code> are implemented as interpreters, and can therefore not be given new interpretations.</p>
<p>Unlike <code>freer-simple</code>, <code>fused-effects</code> has relatively little attention paid to compiler error messaging, which can make common (compile-time) errors somewhat more confusing to diagnose. Similarly, <code>freer-simple</code>’s family of interpreter functions can make the job of defining new effect handlers somewhat easier than in <code>fused-effects</code>. Further, <code>freer-simple</code> provides many of the same effects as <code>fused-effects</code>, plus a coroutine effect, but minus resource management and random generation.</p>
<p>Finally, <code>fused-effects</code> has been <a href="related.html#benchmarks">benchmarked</a> as faster than <code>freer-simple</code>.</p>
<h3 id="comparison-to-polysemy"><a class="header" href="#comparison-to-polysemy">Comparison to <code>polysemy</code></a></h3>
<p>Like <a href="http://hackage.haskell.org/package/polysemy"><code>polysemy</code></a>, <code>fused-effects</code> is a batteries-included effect system capable of scoped, reinterpretable algebraic effects.</p>
<p>As of GHC 8.8, <code>fused-effects</code> outperforms <code>polysemy</code>, though new effects take more code to define in <code>fused-effects</code> than <code>polysemy</code> (though the <code>Control.Carrier.Interpret</code> module provides a low-friction API for rapid prototyping of new effects). Like <code>freer-simple</code> and unlike <code>fused-effects</code>, polysemy provides custom type errors if a given effect invocation is ambigous or invalid in the current context.</p>
<h3 id="comparison-to-eff"><a class="header" href="#comparison-to-eff">Comparison to <code>eff</code></a></h3>
<p><a href="https://github.com/lexi-lambda/eff"><code>eff</code></a> is similar in many ways to <code>fused-effects</code>, but is slightly more performant due to its representation of effects as typeclasses. This approach lets GHC generate better code in exchange for sacrificing the flexibility associated with effects represented as data types. <code>eff</code> also uses the <code>monad-control</code> package to lift effects between contexts rather than implementing an <code>Algebra</code>-style class itself.</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>The authors of fused-effects would like to thank:</p>
<ul>
<li>Tom Schrijvers, Nicholas Wu, and all their collaborators for the research that led to <code>fused-effects</code>;</li>
<li>Alexis King for thoughtful discussions about and suggestions regarding our methodology;</li>
<li>the authors of other effect libraries, including <code>eff</code>, <code>polysemy</code>, and <code>capabilities</code>, for their exploration of the space.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faqs"><a class="header" href="#faqs">FAQs</a></h1>
<h2 id="why-is-algebra-called-algebra-and-not-something-more-specific-to-the-interpretation-of-effects"><a class="header" href="#why-is-algebra-called-algebra-and-not-something-more-specific-to-the-interpretation-of-effects">Why is <code>Algebra</code> called <code>Algebra</code>, and not something more specific to the interpretation of effects?</a></h2>
<p>In previous versions of <code>fused-effects</code>, <code>Algebra</code> was called <code>Carrier</code>. The authors chose to rename this to keep it in line with the literature (the corresponding typeclass is called <code>TermAlgebra</code> in <em>Fusion for Free</em>), emphasize the importance of morphisms over objects, and emphasize its similarity to the common Haskell idiom of <a href="https://www.schoolofhaskell.com/user/bartosz/understanding-algebras">F-algebras</a>. The term “algebra” stems from the Arabic جبر, <em>jabr</em>, which roughly translates to “reunion” or “restoration”. This property is most clearly visible in the <code>alg</code> method’s original type signature:</p>
<pre><code class="language-haskell">alg :: sig m a -&gt; m a
</code></pre>
<p>Like the traditional encoding of F-algebras (<code>f a -&gt; a</code>), this describes a function that reunites an effect signature <code>sig</code> with its monadic context <code>m</code>.</p>
<p>In 1.1.0.0, <code>alg</code> was given an extended signature:</p>
<pre><code class="language-haskell">alg :: Functor ctx =&gt; Handler ctx n m -&gt; sig n a -&gt; ctx () -&gt; m (ctx a)
</code></pre>
<p>Ignoring <code>ctx</code> for the moment, this corresponds to higher-order <em>Mendler iteration</em>: instead of the algebra receiving a signature containing <code>m</code>s, it receives an algebra containing some other (universally quantified) type <code>n</code>, plus a handler function lowering <code>n</code> to <code>m</code>, similar to how <code>foldMap</code> takes a structure <code>t a</code> and reduces the <code>a</code>s to some <code>Monoid</code> <code>m</code> using a function <code>a -&gt; m</code>.</p>
<p>The context occurs in both <code>alg</code> and the handler in order to correctly lower stateful monad transformers <code>t m</code> to <code>m</code> while carrying along whatever context they need to resume: for <code>ExceptT e</code> this is <code>Either e</code>, for <code>StateT s</code> it’s <code>(,) s</code>, and so on. So all told, <code>alg</code> is a state-preserving Mendler-style <code>sig</code>-algebra.</p>
<h2 id="when-do-i-need-to-use-the-type-application-foo-syntax"><a class="header" href="#when-do-i-need-to-use-the-type-application-foo-syntax">When do I need to use the type application (<code>@Foo</code>) syntax?</a></h2>
<p>Because a given effectful operation can have multiple <code>State</code> or <code>Reader</code> effects, your code may fail to typecheck if it invokes an ambiguous state or reader effect, such as follows:</p>
<pre><code class="language-haskell">ambig :: (Has (State Int) sig m, Has (State Float) sig m, MonadIO m) =&gt; m ()
ambig = do
  item &lt;- get
  liftIO . putStrLn $ "got item: " &lt;&gt; show item
</code></pre>
<p>Because the <code>item</code> variable is not annotated with a concrete type, GHC will try to infer which we you meant. In this case, it is unable to, as <code>item</code> is passed to the polymorphic <code>show</code> function. Because both <code>Int</code> and <code>Float</code> values can be passed to <code>show</code>, GHC will reject this program with an error relating to ambiguous types. The <code>-XTypeApplications</code> extension to GHC provides a syntactically clean way to specify which type we meant:</p>
<pre><code class="language-haskell">okay :: (Has (State Int) sig m, Has (State Float) sig m, MonadIO m) =&gt; m ()
okay = do
  item &lt;- get @Int
  liftIO . putStrLn $ "got item: " &lt;&gt; show item
</code></pre>
<p>The <code>@Int</code> syntax—an <em>explicit type application</em> specifies that the return type of <code>get</code> must in this case be an <code>Int</code>. For more information about type applications, consult the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/type_applications.html#extension-TypeApplications">GHC manual</a>.</p>
<h2 id="how-can-i-build-effect-stacks-that-interoperate-correctly-with-mtl"><a class="header" href="#how-can-i-build-effect-stacks-that-interoperate-correctly-with-mtl">How can I build effect stacks that interoperate correctly with <code>mtl</code>?</a></h2>
<p>There are three approaches:</p>
<ol>
<li>
<p>Use the monadic types defined by <code>transformers</code> as the carriers for your effects. The resulting composition of monads will interoperate with <code>mtl</code> and any <code>mtl</code>-compatible library.</p>
</li>
<li>
<p>Wrap an existing monad stack with a phantom type representing some relevant effect information:</p>
<pre><code class="language-haskell">newtype Wrapper s m a = Wrapper { runWrapper :: m a }
  deriving (Algebra sig, Applicative, Functor, Monad)

getState :: Has (State s) sig m =&gt; Wrapper s m s
getState = get
</code></pre>
<p>Indeed, <code>Wrapper</code> can now be made an instance of <code>MonadState</code>:</p>
<pre><code class="language-haskell">instance Has (State s) sig m =&gt; MTL.MonadState s (Wrapper s m) where
  get = Control.Effect.State.get
  put = Control.Effect.State.put
</code></pre>
</li>
<li>
<p>Use <code>Control.Effect.Labelled</code> to define an instance for some specific label:</p>
<pre><code class="language-haskell">instance HasLabelled State (State s) sig m =&gt; MTL.MonadState s (Wrapper s m) where
  get = Control.Effect.State.Labelled.get @State
  put = Control.Effect.State.Labelled.put @State
</code></pre>
<p>Now <code>Wrapper</code> has a <code>MonadState</code> instance whenever <code>m</code> has an appropriately-labelled <code>State</code> effect, which can be provided by the <code>Control.Effect.Labelled.Labelled</code> carrier.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releasing-new-versions"><a class="header" href="#releasing-new-versions">Releasing new versions</a></h1>
<p>This checklist is designed to help @robrix remember the steps involved in making a new release.</p>
<ul>
<li><input disabled="" type="checkbox"/>
Determine whether the release constitutes a major, minor, or patch version bump under the PVP.</li>
<li><input disabled="" type="checkbox"/>
Make a branch with the name <code>version-x.y.z.w</code>.</li>
<li><input disabled="" type="checkbox"/>
Add a heading to the top of <code>ChangeLog.md</code> for the current version.</li>
<li><input disabled="" type="checkbox"/>
Change the version of the package in <code>fused-effects.cabal</code>.</li>
<li><input disabled="" type="checkbox"/>
Push the branch to GitHub and open a draft PR. Double-check the changes, comparing against a previous release PR, e.g. https://github.com/fused-effects/fused-effects/pull/80. When satisfied, mark the PR as ready for review, and request a review from a collaborator.</li>
<li><input disabled="" type="checkbox"/>
Build locally using <code>cabal v2-build</code>, then collect the sources and docs with <code>cabal v2-sdist</code> and <code>cabal v2-haddock --haddock-for-hackage</code>, respectively. Note the paths to the tarballs in the output of these commands.</li>
<li><input disabled="" type="checkbox"/>
Publish a candidate release to Hackage with <code>cabal upload dist-newstyle/sdist/fused-effects-x.y.z.w.tar.gz</code> and <code>cabal upload --documentation dist-newstyle/fused-effects-x.y.z.w-docs.tar.gz</code>. Add a link to the candidate release in a comment on the PR.</li>
<li><input disabled="" type="checkbox"/>
Once the PR has been approved and you’re satisfied with the candidate release, merge the PR. Publish the release to Hackage by running the above commands with the addition of <code>--publish</code>.</li>
<li><input disabled="" type="checkbox"/>
Locally, check out <code>master</code> and pull the latest changes to your working copy. Make a new tag, e.g. <code>git tag x.y.z.w</code>. Push tags to GitHub using <code>git push --tags</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
